/*
   A.Segment Tree Explanation (Sum on a Segment)
   ------------------------------------------

   A Segment Tree is a data structure that allows us to efficiently perform 
   range-based queries and updates on an array. It is especially useful for problems 
   like finding the sum of elements in a given range and updating elements at 
   specific indices.

   The basic idea behind a segment tree is to build a binary tree where each node 
   represents the sum of a segment (range) of the array. By doing so, we can answer 
   range queries and apply updates in logarithmic time.

   Example:
   Let's consider the following array:

   Array: [1, 3, 5, 7, 9, 11]
   Index:  0  1  2  3  4  5

   Visual Representation of the Segment Tree:
   
                              [1, 3, 5, 7, 9, 11] => Sum = 36
                             /                     \
               [1, 3, 5] => Sum = 9          [7, 9, 11] => Sum = 27
               /          \                      /           \
        [1, 3] => Sum = 4   [5] => Sum = 5  [7, 9] => Sum = 16   [11] => Sum = 11
         /   \                               /   \
     [1]     [3]                        [7]       [9]

   The leaf nodes represent the individual elements of the array. Each internal 
   node contains the sum of its two children, representing the sum over a segment 
   of the array.

   How Queries Work:
   -----------------
   Suppose we want to find the sum of elements from index 1 to 4 (inclusive of 1, 
   exclusive of 4) in the array [1, 3, 5, 7, 9, 11]. This range corresponds to 
   [3, 5, 7] in the array. Let's see how the segment tree helps:

   1. The query asks for the sum of the range [1, 4), i.e., indices 1, 2, 3.
   2. We begin at the root node, which covers the entire array. Since the query 
      only partially overlaps with this node's range, we need to check both children.
   3. For the left child (range [0, 2]), only part of this range overlaps with 
      the query range. We need to go deeper.
   4. For the right child (range [3, 5]), the query completely overlaps with 
      the left part (range [3, 4]). We can take its value directly.
   5. The result is the sum of the overlapping parts, which is 3 + 5 + 7 = 15.

   Updates in Segment Tree:
   ------------------------
   When we want to update an element in the array (for example, change the value at 
   index 2 from 5 to 6), we need to propagate this change up the tree.

   Steps:
   1. Update the leaf node corresponding to index 2.
   2. Recalculate the sum at each internal node that is affected by the change.
   3. The update is complete after propagating the change up to the root.

   Time Complexity:
   ----------------
   Both the query and update operations take O(log n) time, where n is the size of 
   the array. This is because the height of the segment tree is log n, and we 
   traverse only one path from the root to a leaf for updates and queries.

   Example for Update:
   -------------------
   Array before update: [1, 3, 5, 7, 9, 11]
   Update: set a[2] = 6

   Segment Tree before update:
                              [1, 3, 5, 7, 9, 11] => Sum = 36
                             /                     \
               [1, 3, 5] => Sum = 9          [7, 9, 11] => Sum = 27
               /          \                      /           \
        [1, 3] => Sum = 4   [5] => Sum = 5  [7, 9] => Sum = 16   [11] => Sum = 11
         /   \                               /   \
     [1]     [3]                        [7]       [9]

   After update:
                              [1, 3, 6, 7, 9, 11] => Sum = 37
                             /                     \
               [1, 3, 6] => Sum = 10         [7, 9, 11] => Sum = 27
               /          \                      /           \
        [1, 3] => Sum = 4   [6] => Sum = 6  [7, 9] => Sum = 16   [11] => Sum = 11
         /   \                               /   \
     [1]     [3]                        [7]       [9]

   As you can see, only the affected nodes are updated, making this an efficient
   process.

   Summary:
   --------
   - Segment trees are used to efficiently perform range queries and updates.
   - They allow us to handle queries like sum, min, max, etc., over a range.
   - Time complexity for both updates and queries is O(log n), making segment 
     trees ideal for large arrays.
*/

/*
   B.Segment Tree for the Minimum (Minimum on a Segment)
   ----------------------------------------------

   A Segment Tree can be used to efficiently compute the minimum element on a given 
   range (segment) of an array and handle updates where an element in the array 
   is modified. Just like in the sum query problem, we can build a binary tree 
   where each node stores the minimum value of a segment, instead of the sum.

   Example:
   Let's consider the following array:

   Array: [5, 2, 7, 3, 8, 6]
   Index:  0  1  2  3  4  5

   Visual Representation of the Segment Tree for Minimum:
   
                              [0, 5] => Min = 2
                             /                 \
                 [0, 2] => Min = 2       [3, 5] => Min = 3
                 /          \                  /          \
       [0, 1] => Min = 2   [2] => 7    [3, 4] => Min = 3   [5] => 6
        /   \                             /   \
    [0] => 5  [1] => 2              [3] => 3   [4] => 8

   Here, the leaf nodes represent the individual elements of the array, and 
   each internal node stores the minimum value of its child segments. 
   This structure enables us to efficiently find the minimum value over a range 
   and update elements in the array.

   How Queries Work:
   -----------------
   Suppose we want to find the minimum of elements from index 1 to 4 (inclusive of 1, 
   exclusive of 4) in the array [5, 2, 7, 3, 8, 6]. This range corresponds to 
   [2, 7, 3] in the array. Let's see how the segment tree helps:

   1. The query asks for the minimum in the range [1, 4).
   2. Starting at the root, we notice that this query partially overlaps with the 
      entire range [0, 5], so we check both the left and right children.
   3. For the left child (range [0, 2]), only part of this range overlaps with the 
      query range [1, 4). We continue searching down the left subtree.
   4. For the right child (range [3, 5]), we check the left child (range [3, 4]), 
      which fully overlaps with the query range. Its minimum is added to the result.
   5. The result is the minimum of the overlapping parts, which is min(2, 3) = 2.

   Updates in Segment Tree:
   ------------------------
   When we want to update an element in the array (for example, change the value at 
   index 2 from 7 to 1), we need to propagate this change up the tree.

   Steps:
   1. Update the leaf node corresponding to index 2.
   2. Recalculate the minimum at each internal node that is affected by the change.
   3. The update is complete after propagating the change up to the root.

   Time Complexity:
   ----------------
   Both the query and update operations take O(log n) time, where n is the size of 
   the array. This is because the height of the segment tree is log n, and we 
   traverse only one path from the root to a leaf for updates and queries.

   Example for Update:
   -------------------
   Array before update: [5, 2, 7, 3, 8, 6]
   Update: set a[2] = 1

   Segment Tree before update:
                              [0, 5] => Min = 2
                             /                 \
                 [0, 2] => Min = 2       [3, 5] => Min = 3
                 /          \                  /          \
       [0, 1] => Min = 2   [2] => 7    [3, 4] => Min = 3   [5] => 6
        /   \                             /   \
    [0] => 5  [1] => 2              [3] => 3   [4] => 8

   After update:
                              [0, 5] => Min = 1
                             /                 \
                 [0, 2] => Min = 1       [3, 5] => Min = 3
                 /          \                  /          \
       [0, 1] => Min = 2   [2] => 1    [3, 4] => Min = 3   [5] => 6
        /   \                             /   \
    [0] => 5  [1] => 2              [3] => 3   [4] => 8

   As you can see, only the affected nodes are updated, making this an efficient 
   process.

   Input/Output Format:
   --------------------
   - Input: 
     - First line: two integers n and m (1 ≤ n, m ≤ 100000) representing the size 
       of the array and the number of operations.
     - Second line: n integers ai (0 ≤ ai ≤ 10^9) representing the array elements.
     - Next m lines: each line describes an operation:
       - "1 i v": Update the element at index i to value v.
       - "2 l r": Find the minimum value in the range [l, r) (inclusive of l, 
         exclusive of r).
   
   - Output:
     - For each "2 l r" query, output the minimum value in the range [l, r).

   Summary:
   --------
   - Segment trees are highly efficient for range queries and point updates.
   - Both operations take O(log n) time due to the tree's balanced nature.
   - This problem showcases the use of segment trees to compute the minimum over a 
     range in logarithmic time.
*/

/*
   C. Number of Minimums on a Segment (Minimum on Segment with Count of Minimum Elements)
   -----------------------------------------------------------------------------

   This problem extends the concept of the segment tree to not only find the minimum 
   value on a segment but also count how many times that minimum value appears in the 
   segment.

   The Segment Tree Structure:
   ---------------------------
   Each node in the segment tree will now store two pieces of information:
   1. The minimum value in the corresponding segment.
   2. The number of times this minimum value appears in the segment.

   To build the tree, we initialize the leaf nodes with each element of the array. 
   Each internal node stores the minimum value of its two children, and if both 
   children have the same minimum value, we sum their counts. If the minimum value 
   differs, we select the minimum value and the corresponding count.

   Example:
   Let's take an example array:

   Array: [5, 2, 7, 3, 3, 6]
   Index:  0  1  2  3  4  5

   Visual Representation of Segment Tree (Minimum and Count):

                              [0, 5] => Min = 2, Count = 1
                             /                             \
                 [0, 2] => Min = 2, Count = 1       [3, 5] => Min = 3, Count = 2
                 /                \                         /                 \
       [0, 1] => Min = 2, Count = 1   [2] => Min = 7, Count = 1     [3, 4] => Min = 3, Count = 2  [5] => Min = 6, Count = 1
        /   \                                                                         
    [0] => Min = 5, Count = 1   [1] => Min = 2, Count = 1       [3] => Min = 3, Count = 1   [4] => Min = 3, Count = 1

   1. The root node stores the minimum value in the entire array (2) and the count of 
      that minimum value (1 in this case).
   2. For the left subtree [0, 2], the minimum value is 2, which appears once.
   3. For the right subtree [3, 5], the minimum value is 3, which appears twice.

   Queries:
   --------
   Let's consider a query to find the minimum and its count in the range [1, 4). 
   This means we are interested in the subarray [2, 7, 3].

   - The segment tree will check the nodes corresponding to this range.
   - It will first look at the left subtree [1, 2] (which has the minimum 2 with count 1).
   - Then, it will consider the right subtree [3, 3], which has the minimum value 3 with count 1.
   - The result of this query is min(2, 3) = 2 with count 1.

   Updates:
   --------
   If an element in the array is updated, we need to propagate this change up the 
   tree, just like in the previous segment tree problems. However, in addition to 
   updating the minimum value, we also need to update the count of the minimum 
   value in the affected nodes.

   For example, if the element at index 2 is updated from 7 to 1, we would update 
   the leaf node corresponding to index 2 and then recalculate the internal nodes 
   that depend on this change. This ensures that the tree correctly reflects the 
   new minimum and count for all affected segments.

   Time Complexity:
   ----------------
   - Query: O(log n)
   - Update: O(log n)
   These operations are efficient because the segment tree has a height of log n, 
   and only one path from the root to a leaf is affected during an update or query.

   Example for Update:
   -------------------
   Array before update: [5, 2, 7, 3, 3, 6]
   Update: set a[2] = 1

   Segment Tree before update:
                              [0, 5] => Min = 2, Count = 1
                             /                             \
                 [0, 2] => Min = 2, Count = 1       [3, 5] => Min = 3, Count = 2
                 /                \                         /                 \
       [0, 1] => Min = 2, Count = 1   [2] => Min = 7, Count = 1     [3, 4] => Min = 3, Count = 2  [5] => Min = 6, Count = 1
        /   \                                                                         
    [0] => Min = 5, Count = 1   [1] => Min = 2, Count = 1       [3] => Min = 3, Count = 1   [4] => Min = 3, Count = 1

   After update:
                              [0, 5] => Min = 1, Count = 1
                             /                             \
                 [0, 2] => Min = 1, Count = 1       [3, 5] => Min = 3, Count = 2
                 /                \                         /                 \
       [0, 1] => Min = 2, Count = 1   [2] => Min = 1, Count = 1     [3, 4] => Min = 3, Count = 2  [5] => Min = 6, Count = 1
        /   \                                                                         
    [0] => Min = 5, Count = 1   [1] => Min = 2, Count = 1       [3] => Min = 3, Count = 1   [4] => Min = 3, Count = 1

   As you can see, the tree reflects the change at index 2 and updates the minimum 
   and count accordingly.

   Input/Output Format:
   --------------------
   - Input:
     - First line: two integers n and m (1 ≤ n, m ≤ 100000) representing the size 
       of the array and the number of operations.
     - Second line: n integers ai (0 ≤ ai ≤ 10^9) representing the array elements.
     - Next m lines: each line describes an operation:
       - "1 i v": Update the element at index i to value v.
       - "2 l r": Find the minimum value and the count of that minimum value in the 
         range [l, r).

   - Output:
     - For each "2 l r" query, output two integers: the minimum value and the count 
       of that value in the range [l, r).

   Summary:
   --------
   - Segment trees are a powerful data structure that can efficiently solve range 
     queries and handle point updates.
   - By extending the tree nodes to store both the minimum value and its count, we 
     can answer more complex queries in logarithmic time.
   - Both query and update operations take O(log n) time due to the tree's balanced 
     nature.
*/

